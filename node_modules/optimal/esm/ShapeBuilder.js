import _typeof from "@babel/runtime/helpers/esm/typeof";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

/**
 * @copyright   2017-2019, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 */
import Builder from './Builder';
import isObject from './isObject';

var ShapeBuilder = function (_Builder) {
  _inherits(ShapeBuilder, _Builder);

  function ShapeBuilder(contents) {
    var _this;

    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ShapeBuilder);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ShapeBuilder).call(this, 'shape', defaultValue));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "contents", void 0);

    if ("production" !== process.env.NODE_ENV) {
      _this.invariant(isObject(contents) && Object.keys(contents).length > 0 && Object.keys(contents).every(function (key) {
        return contents[key] instanceof Builder;
      }), 'A non-empty object of properties to blueprints are required for a shape.');
    }

    _this.contents = contents;
    return _this;
  }

  _createClass(ShapeBuilder, [{
    key: "runChecks",
    value: function runChecks(path, initialValue, struct) {
      var _this2 = this;

      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var value = {};
      var object = initialValue || this.defaultValue || {};

      if ("production" !== process.env.NODE_ENV) {
        this.invariant(_typeof(object) === 'object' && object, 'Value passed to shape must be an object.', path);
      }

      Object.keys(this.contents).forEach(function (key) {
        var builder = _this2.contents[key];

        if (builder instanceof Builder) {
          value[key] = builder.runChecks("".concat(path, ".").concat(key), object[key], object, options);
        } else {
          value[key] = object[key];
        }
      });
      return value;
    }
  }]);

  return ShapeBuilder;
}(Builder);

export { ShapeBuilder as default };
export function shape(contents) {
  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new ShapeBuilder(contents, defaultValue);
}